"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectSome = expectSome;
exports.expectPublicKey = expectPublicKey;
exports.expectPda = expectPda;
exports.getAccountMetasAndSigners = getAccountMetasAndSigners;
var umi_1 = require("@metaplex-foundation/umi");
/**
 * Asserts that the given value is not null or undefined.
 * @internal
 */
function expectSome(value) {
    if (value == null) {
        throw new Error('Expected a value but received null or undefined.');
    }
    return value;
}
/**
 * Asserts that the given value is a PublicKey.
 * @internal
 */
function expectPublicKey(value) {
    if (!value) {
        throw new Error('Expected a PublicKey.');
    }
    return (0, umi_1.publicKey)(value, false);
}
/**
 * Asserts that the given value is a PDA.
 * @internal
 */
function expectPda(value) {
    if (!value || !Array.isArray(value) || !(0, umi_1.isPda)(value)) {
        throw new Error('Expected a PDA.');
    }
    return value;
}
/**
 * Get account metas and signers from resolved accounts.
 * @internal
 */
function getAccountMetasAndSigners(accounts, optionalAccountStrategy, programId) {
    var keys = [];
    var signers = [];
    accounts.forEach(function (account) {
        if (!account.value) {
            if (optionalAccountStrategy === 'omitted')
                return;
            keys.push({ pubkey: programId, isSigner: false, isWritable: false });
            return;
        }
        if ((0, umi_1.isSigner)(account.value)) {
            signers.push(account.value);
        }
        keys.push({
            pubkey: (0, umi_1.publicKey)(account.value, false),
            isSigner: (0, umi_1.isSigner)(account.value),
            isWritable: account.isWritable,
        });
    });
    return [keys, signers];
}
